"Repository rules for importing remote apk packages"

load(":util.bzl", "util")

APK_IMPORT_TMPL = """\
# Generated by apk_import. DO NOT EDIT
filegroup(
    name = "all",
    srcs = glob(
        ["**/*.tar.gz", "**/*.apk"],
        allow_empty = True,
    ),
    visibility = ["//visibility:public"]
)
"""

def _auth(rctx, url):
    if "HTTP_AUTH" not in rctx.os.environ:
        return {}
    http_auth = rctx.os.environ["HTTP_AUTH"]

    parts = http_auth.split(":", 3)
    if len(parts) != 4:
        fail("malformed HTTP_AUTH environment variable wanted basic:REALM:USER:PASSWORD, but got {} parts", len(parts))

    if parts[0].lower() != "basic":
        fail("malformed HTTP_AUTH environment variable wanted basic:REALM:USER:PASSWORD, but got {} for first part", parts[0])

    if not url.startswith("https://{}".format(parts[1])):
        return {}

    return {
        url: {
            "type": "basic",
            "login": parts[2],
            "password": parts[3],
        },
    }

def _apk_import_impl(rctx):
    """Download a complete APK file directly."""
    # Build the output path: {repo_escaped}/{arch}/{package}-{version}.apk
    repo = util.repo_url(rctx.attr.url, rctx.attr.architecture)
    repo_escaped = util.url_escape(repo)
    apk_output = "{}/{}/{}-{}.apk".format(
        repo_escaped,
        rctx.attr.architecture,
        rctx.attr.package_name,
        rctx.attr.version,
    )

    # Download the full APK
    download_kwargs = {
        "url": [rctx.attr.url],
        "output": apk_output,
        "auth": _auth(rctx, rctx.attr.url),
    }

    # Add integrity check if checksum is provided
    if rctx.attr.checksum:
        download_kwargs["integrity"] = rctx.attr.checksum

    rctx.download(**download_kwargs)
    rctx.file("BUILD.bazel", APK_IMPORT_TMPL)

apk_import = repository_rule(
    implementation = _apk_import_impl,
    attrs = {
        "package_name": attr.string(mandatory = True, doc = "The name of the APK package"),
        "version": attr.string(mandatory = True, doc = "The version of the package"),
        "architecture": attr.string(mandatory = True, doc = "The target architecture (e.g., x86_64, aarch64)"),
        "url": attr.string(mandatory = True, doc = "The URL to download the APK from"),
        "checksum": attr.string(mandatory = False, doc = "Optional integrity checksum (sha256 or sha512 in SRI format)"),
    },
    doc = "Repository rule to download a complete APK package file.",
)

APK_REPOSITORY_TMPL = """\
# Generated by apk_repository. DO NOT EDIT
filegroup(
    name = "index",
    srcs = glob(["**/APKINDEX/*.tar.gz"]),
    visibility = ["//visibility:public"]
)
"""

def _apk_repository_impl(rctx):
    repo = util.repo_url(rctx.attr.url, rctx.attr.architecture)
    repo_escaped = util.url_escape(repo)
    rctx.download(
        url = [rctx.attr.url],
        auth = _auth(rctx, rctx.attr.url),
        output = "{}/{}/APKINDEX/latest.tar.gz".format(repo_escaped, rctx.attr.architecture),
    )
    rctx.file("BUILD.bazel", APK_REPOSITORY_TMPL)

apk_repository = repository_rule(
    implementation = _apk_repository_impl,
    attrs = {
        "url": attr.string(mandatory = True),
        "architecture": attr.string(mandatory = True),
    },
)

APK_KEYRING_TMPL = """\
# Generated by apk_import. DO NOT EDIT
filegroup(
    name = "keyring",
    srcs = ["{public_key}"],
    visibility = ["//visibility:public"]
)
"""

def _cachePathFromURL(url):
    """
    Translates URL to a name of local directory that can be used to represent prefetched content of the URL.

    For RSA public key files (*.rsa.pub), the file is stored in a directory named after the full filename.

    Examples:
      https://packages.wolfi.dev/os/wolfi-signing.rsa.pub              -> https%3A%2F%2Fpackages.wolfi.dev%2F/os/wolfi-signing.rsa.pub/wolfi-signing.rsa.pub
      https://packages.wolfi.dev/os/aarch64/sqlite-libs-3.44.0-r0.apk  -> https%3A%2F%2Fpackages.wolfi.dev%2Fos/arch64/sqlite-libs-3.44.0-r0.apk
    """
    url_split = url.rsplit("/", 2)
    repo = url_split[0]
    if len(repo.split("/")) <= 3:
        # Seems the Apko adds additional "/" if the URL is short.
        repo += "/"
    repo_escaped = util.url_escape(repo)
    filename = url_split[2]

    # For RSA public key files, store them in a directory named after the full filename
    if filename.endswith(".rsa.pub"):
        return "{}/{}/{}/{}".format(repo_escaped, url_split[1], filename, filename)

    return "{}/{}/{}".format(repo_escaped, url_split[1], filename)

def _apk_keyring_impl(rctx):
    public_key = _cachePathFromURL(rctx.attr.url)
    rctx.download(url = [rctx.attr.url], output = public_key, auth = _auth(rctx, rctx.attr.url))
    rctx.file("BUILD.bazel", APK_KEYRING_TMPL.format(public_key = public_key))

apk_keyring = repository_rule(
    implementation = _apk_keyring_impl,
    attrs = {
        "url": attr.string(mandatory = True),
    },
)

def _apk_filegroup_impl(ctx):
    lockfile = depset([ctx.file.lockfile])
    apks = depset(ctx.files.apks)
    indexes = depset(ctx.files.indexes)
    keyrings = depset(ctx.files.keyrings)
    return [
        DefaultInfo(files = depset(transitive = [lockfile, apks, indexes, keyrings])),
        OutputGroupInfo(
            lockfile = lockfile,
            apks = apks,
            indexes = indexes,
            keyrings = keyrings,
        ),
    ]

apk_filegroup = rule(
    implementation = _apk_filegroup_impl,
    attrs = {
        "lockfile": attr.label(doc = "Label to the `apko.lock.json` file.", allow_single_file = True, mandatory = True),
        "keyrings": attr.label_list(doc = "Labels of the keyring (public key) files.", allow_files = True, mandatory = True),
        "apks": attr.label_list(doc = "Labels of the package (apk) files.", allow_files = True, mandatory = True),
        "indexes": attr.label_list(doc = "Labels of the APKINDEX files.", allow_files = True, mandatory = True),
    },
)
