"""Repository rules for translating apko.lock.json"""

load("//apko/private:util.bzl", "util")

_DOC = """Repository rule to generate starlark code from an `apko.lock.json` file.

See [apko-cache.md](./apko-cache.md) documentation.
"""

BUILD_TMPL = """\
load("@rules_apko//apko/private:apk.bzl", "apk_filegroup")

# Generated by apko_translate_lock. DO NOT EDIT.
apk_filegroup(
    name = "contents", 
    lockfile = "{lockfile}",
    apks = {apks},
    indexes = {indexes},
    keyrings = {keyrings},
    visibility = ["//visibility:public"]
)
"""

REPO_TMPL = """\
# Generated by apko_translate_lock. DO NOT EDIT.

load("@rules_apko//apko/private:apk.bzl", "apk_import", "apk_repository", "apk_keyring")

def apko_repositories():
{}
"""

APK_IMPORT_TMPL = """\
    apk_import(
        name = "{name}",
        package_name = "{package_name}",
        version = "{version}",
        architecture = "{architecture}",
        url ="{url}",
        signature_range = "{signature_range}",
        signature_checksum = "{signature_checksum}",
        control_range = "{control_range}",
        control_checksum = "{control_checksum}",
        data_range = "{data_range}",
        data_checksum = "{data_checksum}",
    )
"""

APK_REPOSITORY_TMPL = """\
    apk_repository(
        name = "{name}",
        url = "{url}",
        architecture = "{architecture}",
    )
"""

APK_KEYRING_TMPL = """\
    apk_keyring(
        name = "{name}",
        url = "{url}"
    )
"""

def _translate_apko_lock_impl(rctx):
    lock_file = util.parse_lock(rctx.read(rctx.attr.lock))

    # We copy the lockfile (.lock.json) to avoid visibility problems when we reference it from another module.
    lock_file_local = "lockfile_copy"
    rctx.symlink(rctx.attr.lock, lock_file_local)

    apks = []
    indexes = []
    keyrings = []
    defs = []

    target_name = rctx.attr.target_name if rctx.attr.target_name else rctx.name

    # Parse URL -> repo name mappings if provided (for deduplication across lock files)
    package_repos = json.decode(rctx.attr.package_repos) if rctx.attr.package_repos else {}
    index_repos = json.decode(rctx.attr.index_repos) if rctx.attr.index_repos else {}
    keyring_repos = json.decode(rctx.attr.keyring_repos) if rctx.attr.keyring_repos else {}

    if "keyring" in lock_file["contents"]:
        for keyring in lock_file["contents"]["keyring"]:
            # Use shared repo name from mapping, or fall back to lock-prefixed name
            if keyring["url"] in keyring_repos:
                name = keyring_repos[keyring["url"]]
            else:
                name = util.sanitize_string("{}_{}".format(target_name, keyring["name"]))
            keyrings.append("@{}//:keyring".format(name))
            defs.append(APK_KEYRING_TMPL.format(
                name = name,
                url = keyring["url"],
            ))

    for package in lock_file["contents"]["packages"]:
        # Use shared repo name from mapping, or fall back to lock-prefixed name
        if package["url"] in package_repos:
            name = package_repos[package["url"]]
        else:
            name = util.sanitize_string("{}_{}_{}_{}".format(target_name, package["name"], package["architecture"], package["version"]))
        apks.append("@{}//:all".format(name))

        defs.append(APK_IMPORT_TMPL.format(
            name = name,
            package_name = package["name"],
            version = package["version"],
            architecture = package["architecture"],
            url = package["url"],
            signature_range = package["signature"]["range"],
            signature_checksum = package["signature"]["checksum"],
            control_range = package["control"]["range"],
            control_checksum = package["control"]["checksum"],
            data_range = package["data"]["range"],
            data_checksum = package["data"]["checksum"],
        ))

    for repository in lock_file["contents"]["repositories"]:
        # Use shared repo name from mapping, or fall back to lock-prefixed name
        if repository["url"] in index_repos:
            name = index_repos[repository["url"]]
        else:
            name = util.sanitize_string("{}_{}_{}".format(target_name, repository["name"], repository["architecture"]))
        indexes.append("@{}//:index".format(name))
        defs.append(APK_REPOSITORY_TMPL.format(
            name = name,
            url = repository["url"],
            architecture = repository["architecture"],
        ))

    rctx.file(
        "repositories.bzl",
        REPO_TMPL.format("\n".join(defs)),
    )

    rctx.file(
        "BUILD.bazel",
        BUILD_TMPL.format(apks = apks, keyrings = keyrings, indexes = indexes, lockfile = lock_file_local),
    )

translate_apko_lock = repository_rule(
    implementation = _translate_apko_lock_impl,
    attrs = {
        "lock": attr.label(doc = "label to the `apko.lock.json` file.", mandatory = True),
        "target_name": attr.string(doc = "internal. do not use!"),
        # Attributes for deduplication across lock files (passed by module extension)
        "package_repos": attr.string(doc = "internal. JSON-encoded mapping of package URL to shared repo name.", default = ""),
        "index_repos": attr.string(doc = "internal. JSON-encoded mapping of index URL to shared repo name.", default = ""),
        "keyring_repos": attr.string(doc = "internal. JSON-encoded mapping of keyring URL to shared repo name.", default = ""),
    },
    doc = _DOC,
)
